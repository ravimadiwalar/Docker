  Deployment:
------------
its a recommended way to deploy a pod and RS is the internally it will deploy RS. we use this bcoz in RS and RC we cant update the version of the image we have. but in Deployment 
we can.

Benifits:
* Internally set a RS. it will mange the pods.
* It will set all pod specs.
*Roll back to older deployment version.
*Scale up and down
*pause and resuem the deployment
*Clean up the older RS that you dont need anymore.  


Ex:
consider mavenwebapprs and change the image version to 2 before it had latest. but after applying the kubectl we cant see any changes in the version (Image: dockerhandson/maven-web-app). 

ubuntu@ip-172-31-33-243:~$ kubectl apply -f mavenwebapprs.yml
replicaset.apps/mavenwebapprs configured
service/mavenwebappsvc unchanged
ubuntu@ip-172-31-33-243:~$ kubectl get pods
NAME                  READY   STATUS        RESTARTS   AGE
mavenwebapprs-hb6v7   0/1     Pending       0          34m
mavenwebapprs-hcnvm   1/1     Terminating   0          10h
mavenwebapprs-nz49f   1/1     Terminating   0          10h
mavenwebapprs-w4sjc   0/1     Pending       0          34m
nginxds-qpftp         1/1     Running       0          10h
ubuntu@ip-172-31-33-243:~$ kubectl describe pod mavenwebapprs-w4sjc
Name:           mavenwebapprs-w4sjc
Namespace:      default
Priority:       0
Node:           <none>
Labels:         app=mavenwebapp
Annotations:    <none>
Status:         Pending
IP:
IPs:            <none>
Controlled By:  ReplicaSet/mavenwebapprs
Containers:
  mavenwebappcontainer:
    Image:        dockerhandson/maven-web-app
    Port:         8080/TCP
    Host Port:    0/TCP
    Environment:  <none>
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-5cnpt (ro)
Conditions:
  Type           Status
  PodScheduled   False
Volumes:
  default-token-5cnpt:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-5cnpt
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  <none>
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type     Reason            Age                   From               Message
  ----     ------            ----                  ----               -------
  Warning  FailedScheduling  3m20s (x31 over 34m)  default-scheduler  0/2 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't tolerate, 1 node(s) had taint {node.kubernetes.io/unreachable: }, that the pod didn't tolerate.

Deployment startegies: These strategies will not applicable when we are craeting new pods. bcoz it will recrete new pods once old ones terminate/kill. 
------------------------
1) Recreate- When i am updating my deployment using Recrete strategy, all the old pods are killed all at once and get replaced all at once with new ones.
* here will face some downtime in deployment. why bcoz all will kill once and create once with new onec. so user will face some downtime issue.

strategy:
  type: Recreate

2)Rollung update(Default)- here will will not not face zero downtime deployment issue. whay bcoz a rolling update waits for new pods to become ready before it starts scaling 
down the old ones. if there is a problem , the rolling update or deployment can be aborted without bringing the whole clusterdown. in the YAML definition file for this type of
deployment, a new image replace the old image. 

strategy:
  type: RollingUpdate
  rollinUpdate:
    maxSurge: 1
    maxUnavailable: 1
    minReadSeconds: 30


Lets craete a recrete strategy: i have just update the required lines. 

ubuntu@ip-172-31-33-243:~$ cp javawebapprc.yml javawebappdeployment.yml
ubuntu@ip-172-31-33-243:~$ vi javawebappdeployment.yml
ubuntu@ip-172-31-33-243:~$ cat javawebappdeployment.yml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: javawebappdeployment
spec:
  replicas: 2     #internaly it will create RS
  selector:
     matchLabels:
       app: javawebapp
  strategy:
    type: Recreate   #This strategy will applicable whiel updating the version
  template:
    metadata:
      name: javawebapppod
      labels:
        app: javawebapp
    spec:
      containers:
      - name: javawebappcontainer
        image: dockerhandson/java-web-app:1
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: javawebappsvc
spec:
  type: NodePort
  selector:
    app: javawebapp
  ports:
  - port: 80
    targetPort: 8080

ubuntu@ip-172-31-33-243:~$ kubectl apply -f javawebappdeployment.yml
deployment.apps/javawebappdeployment created
service/javawebappsvc created


*"watch kubectl get pods" --> it will be used to see the live pods craetion and termination in worker nodes while applyig the kubectl appy command. 

ubuntu@ip-172-31-33-243:~$ kubectl get svc
NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
javawebappsvc   NodePort    10.102.134.133   <none>        80:32098/TCP   12m
kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP        25m


Now go and browse with svc nodeport. 

Now lets update the version to 4 and apply the ctl and browse we may face some downtime issue. after some time will get that application. 

ubuntu@ip-172-31-33-243:~$ kubectl get svc
NAME            TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
javawebappsvc   NodePort    10.102.134.133   <none>        80:32098/TCP   26m
kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP        39m
ubuntu@ip-172-31-33-243:~$ kubectl get all
NAME                                        READY   STATUS    RESTARTS   AGE
pod/javawebappdeployment-6b6d59d84c-6fpxl   1/1     Running   0          3m56s
pod/javawebappdeployment-6b6d59d84c-j6rjq   1/1     Running   0          3m56s

NAME                    TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
service/javawebappsvc   NodePort    10.102.134.133   <none>        80:32098/TCP   29m
service/kubernetes      ClusterIP   10.96.0.1        <none>        443/TCP        42m

NAME                                   READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/javawebappdeployment   2/2     2            2           29m

NAME                                              DESIRED   CURRENT   READY   AGE
replicaset.apps/javawebappdeployment-6b6d59d84c   2         2         2       3m56s
replicaset.apps/javawebappdeployment-7cb95f67b4   0         0         0       29m


* here we can see 2 RS.  - NAME                                              DESIRED   CURRENT   READY   AGE
                           replicaset.apps/javawebappdeployment-6b6d59d84c   2         2         2       3m56s
                          replicaset.apps/javawebappdeployment-7cb95f67b4   0         0         0       29m 


one we can see desired 2 and current 2. and other one is zero. bcoz this zero one is older version tahts why it is zero. 

#using "kubectl rollout status deployment <Deploymentname>" we can find out the status . 

ubuntu@ip-172-31-33-243:~$ kubectl rollout status deployment javawebappdeployment
deployment "javawebappdeployment" successfully rolled out

We can see the History also. How many revisions of the deployment ==> "kubectl rollout history deployment <Deploymentname>"

ubuntu@ip-172-31-33-243:~$ kubectl rollout history deployment javawebappdeployment
deployment.apps/javawebappdeployment
REVISION  CHANGE-CAUSE
1         <none>
2         <none>


To know what pod template has been used in both versions==>  kubectl rollout history deployment <deploymentName> --revision=1
                                                             kubectl rollout history deployment <deploymentName> --revision=1

ubuntu@ip-172-31-33-243:~$ kubectl rollout history deployment javawebappdeployment --revision=1
deployment.apps/javawebappdeployment with revision #1
Pod Template:
  Labels:       app=javawebapp
        pod-template-hash=7cb95f67b4
  Containers:
   javawebappcontainer:
    Image:      dockerhandson/java-web-app:1
    Port:       8080/TCP
    Host Port:  0/TCP
    Environment:        <none>
    Mounts:     <none>
  Volumes:      <none>

We can see the same version in "kubectl describe pod <podname>" to just check for confirmation. 

* If required we can rollback to required version. ==> "kubectl rollout undo deployment <deploymentname> --to-revision=1"

ubuntu@ip-172-31-33-243:~$ kubectl rollout undo deployment javawebappdeployment --to-revision=1
deployment.apps/javawebappdeployment rolled back

above we have mentioned the version we wanted. if we dont emntion also it will consider the previous one by default. 
































