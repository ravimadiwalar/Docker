if we get an error  While creating an image and it has already created an half image. then we correct that error and 
and build the image again it will consider it from that error point. and after building also if you run that also if you biuld 
it doesn't take much time bcoz it will take that all from cache.

Below i have just created an image without tagging to any repo. 

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ cat Dockerfile
FROM ubuntu
MAINTAINER Mithun Tech <mithuntechtarining@gmail.com>
RUN ["echo",  "Welcome from RUNONE"]
RUN mkdir -p /opt/test
RUN echo RUNTWO
RUN apt update -y && apt install git -y
CMD ["echo", "Welcome to CMD"]

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$
ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker build -t imageone .
Sending build context to Docker daemon  2.048kB
Step 1/7 : FROM ubuntu
 ---> 5a81c4b8502e
Step 2/7 : MAINTAINER Mithun Tech <mithuntechtarining@gmail.com>
 ---> Using cache
 ---> c3b511654159
Step 3/7 : RUN ["echo",  "Welcome from RUNONE"]
 ---> Using cache
 ---> 5be5d61ad9dd
Step 4/7 : RUN mkdir -p /opt/test
 ---> Using cache
 ---> 943dd35665eb
Step 5/7 : RUN echo RUNTWO
 ---> Using cache
 ---> d6fe66971192
Step 6/7 : RUN apt update -y && apt install git -y
 ---> Using cache
 ---> cdca12f39691
Step 7/7 : CMD ["echo", "Welcome to CMD"]
 ---> Using cache
 ---> 5d82d9263afc
Successfully built 5d82d9263afc
Successfully tagged imageone:latest

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker run imageone
Welcome to CMD

Above we have created a container with no ports bcoz i dont have any application here. that CMD command has 
this much instructions "Welcome to CMD" so it has got executed. and chek the conatiner docker ps -a --> it would
give one uniqe name.

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker run imageone date
Sun Aug 13 03:47:59 UTC 2023

above we have added one more command date (pass date command) whle creating a conatiner. but it executed that date 
command in console. here we have override the CMD.

If we give one more CMD. while running the container it will consider last one and display accordingly.

*How can we see the layers of the image?
docker history <image name/ID>

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker history 5d82d9263afc
IMAGE          CREATED        CREATED BY                                      SIZE      COMMENT
5d82d9263afc   13 hours ago   /bin/sh -c #(nop)  CMD ["echo" "Welcome to C…   0B
cdca12f39691   13 hours ago   /bin/sh -c apt update -y && apt install git …   118MB
d6fe66971192   13 hours ago   /bin/sh -c echo RUNTWO                          0B
943dd35665eb   13 hours ago   /bin/sh -c mkdir -p /opt/test                   0B
5be5d61ad9dd   13 hours ago   echo Welcome from RUNONE                        0B
c3b511654159   13 hours ago   /bin/sh -c #(nop)  MAINTAINER Mithun Tech <m…   0B
5a81c4b8502e   6 weeks ago    /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B
<missing>      6 weeks ago    /bin/sh -c #(nop) ADD file:140fb5108b4a2861b…   77.8MB
<missing>      6 weeks ago    /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B
<missing>      6 weeks ago    /bin/sh -c #(nop)  LABEL org.opencontainers.…   0B
<missing>      6 weeks ago    /bin/sh -c #(nop)  ARG LAUNCHPAD_BUILD_ARCH     0B
<missing>      6 weeks ago    /bin/sh -c #(nop)  ARG RELEASE                  0B

 last 5 missing layers are from base image and top ones are from our created image.

*If we are building a image again it will take that from cache but we dont want that to take it from cache. so that time 
==> docker build -t imageone --no-cache

==> ENTRYPOINT
ENTRYPOINT also executes while running a container. 

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ vi dockerfile_ENT
ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ cat dockerfile_ENT
FROM centos
RUN ["echo", "RUNONE"]
ENTRYPOINT ["echo", "welcometoentrypoint]"

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker build -t imagetwo -f /home/ubuntu/Dockerfile_lab/dockerfile_ENT .
Sending build context to Docker daemon  3.072kB
Step 1/3 : FROM centos
latest: Pulling from library/centos
a1d0c7532777: Pull complete
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
Status: Downloaded newer image for centos:latest
 ---> 5d0da3dc9764
Step 2/3 : RUN ["echo", "RUNONE"]
 ---> Running in b23f0f891eb3
RUNONE
Removing intermediate container b23f0f891eb3
 ---> 0527f3528feb
Step 3/3 : ENTRYPOINT ["echo", "welcometoentrypoint]"
 ---> Running in 299026270ff8
Removing intermediate container 299026270ff8
 ---> 292dd08fb3c4
Successfully built 292dd08fb3c4
Successfully tagged imagetwo:latest

Above we have given a path to that new file. bcoz it will not identify if its in other name than just dockerfile and it
has two dockerfiles there. so we should give path while building an image.
But ENTRYPOINT hasn't executed yet. it will execute while running a conatiner.

if we give date command at the end. it wil display that only not todays date. bcoz ENTRYPOINT will consider that as an argument.

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker run imagetwo date
welcometoentrypoint date

*What if CMD and ENTRYPOINT in single dockerfile?
it will consider ENTRYPOINT and CMD instructions as an argumnets to that ENTRYPOINT(display at the end). if we give date command 
at the end while running the container. it will override and consider date not CMD instructins.

==>WORKDIR- Change/Switch Directory

Usig this will set a working directory of the container. Whatever instructions are after this WORKDIR will execute 
under set directory.

Sometimes if we dont mention that workdir also it will take one work directory. bcoz it was set in our base image.

ubuntu@ip-172-31-0-166:~$ docker run imageone pwd
/
ubuntu@ip-172-31-0-166:~$ docker exec 32a4fc8f848d pwd
/app
ubuntu@ip-172-31-0-166:~$ docker exec -it 32a4fc8f848d bash
root@32a4fc8f848d:/app#

abovee we can see the container is running under root and i entered inside the container bash and there also we 
can see root. it means they set root for all. we may not find out in our docker file but it might be in base image.


==>USER- We can set user for a container as a which user we want to execute commands in a container. Switching the user
within the conatiner.

To find out the USER- docker top <containerName/ID>

ubuntu@ip-172-31-0-166:~$ docker top 32a4fc8f848d
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                1529                1506                1                   12:48               ?                   00:00:00            python manage.py runserver 0.0.0.0:8001
root                1556                1529                7                   12:48               ?                   00:00:01            /usr/local/bin/python manage.py runserver 0.0.0.0:8001

Above we can see root user. we can find out this root inside the base file/anywhere. 
USER - we can set however we want. in stagewise also we can change. based on that the user will change. we cant see any 
useradd command in that file. then where it is? it might in our base image dockerfile.

==> ENV - We can set/Export environment variables for an image and container.
If we want we can set our own ENV.

ENV <key> <value>
EX: ENV CATALINA_HOME /usr/local/tomcat

We can find out the ENV in both images and containers if we set. in images if we want to see we use command
--> docker inspect <imagename/ID>

*We can pass ENV while running the container also==> docker run --env <key>=<value>
                                                 OR    docker run -e <key>=<value>

Sometimes we need diff variables for each environment(staging/QA/Prod). so that time we need this ENV while running a container.

Based on these we can check also

ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
ubuntu@ip-172-31-0-166:~/Dockerfile_lab$ docker exec -it 32a4fc8f848d  bash
root@32a4fc8f848d:/app# echo $PATH
/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

We could see all these ENV's in every dockerfile. EX: check the java any version . there we will get that all ENV they set.

==> ARG - We can define variables like ENV in dokcerfile. These are normal variables.

ARG <key>=<value>

*What is the diff btw ENV and ARG in docker?
=>These argumnets (ARG) will be accessible only within the docker file and will be used only while creating an image. 
but ENv will be used within the dockerfile and after creating an Image and container also.

*Can we pass an arguments to docker while creatimg an image?
Yes

EX: idont want to hardcore the file name in COPY.
FROM centos
ARG filename=java-web-app.war
COPY target/$filename /usr/local/tomcat

above it will conisder java-web-app.war as a filename while creating an image. 
if we want we can pass that ARG while building an image.
--> docker build -t imagefour --build-arg filename=abc.war .
For above one it will take file name as a abc.war


==>LABEL- LABELS are key value pairs we can set/add labels to image. its a kind of meta data(Its data about data).

To know the branch name of the created image. Below we can see the barnch name that we have mentioned is develop. if we clone
the code from other than develop branch the label will always be develop. but thats wrong. to do that we have to add ARG.

FROM openjdk
ARG branchname=develop
LABEL branch $branchname
COPY target/userprofile.jar  /app/userprofile.jar
WORKDIR /app
ENTRYPOINT ['java' , '-jar' , 'userprofile.jar']

Now go and execute "docker inspect"   here we can see the branch name.
If we dont pass any arguments while creating an image. the branch name will always be develop. so we need to pass ARG.

docker build -t containerregistry/userprofile:1 --build-arg branchname=feature
docker inspect containerregistry/userprofile:1

now it will display feature as a branchname. 


==> EXPOSE <port#>
Its a kind of documnetation to indicate  on which  port container is listening/running. 
EX: EXPOSE 8080
EXPOSE 8000

Using this we can just indicate/expose the port no that we have used. if we give different port No here it will not 
change any port that we have already set. its just to understand while deplying the image.

docker inspect <imagename/ID>

using this command we can find out the port no. 


==> VOLUME <dir>
Whatever data in the conatiner will be deleted once we delete the conatiner.if we need to retain some dir even after deleting
also will use VOLUME

==>EXAMPLE:

If its a node.js application. first clone this project and then write a Dockerfile.inside we can see package.json. its like
pem file in nodejs.it contains all dependenciies. 

FROM node:10 (If we dont give any version it will consider latest one).
MAINTAINER Mithun Tech <emailID>
RUN mkdir -p /usr/app  ( we have created one path)
WORKDIR /usr/app  (set current directory to run the application)
COPY . .  (copying the application in current dir of the system to current dir of image)
RUN npm install  (it will install all required dependencies while creating an image)
EXPOSE 9981
CMD ["node" , "app.js"]  (node is to start the nodejs application. we can use "npm start"also. app.js is nodejs main scrpit)


If we dont want copy some files in the image. so that time we have to craete one file with the name of ".dockeignore" and
mention the file names which i dont want to copy.

Git clone http:
sudo apt update -y
sudo apt install docker.io -y
sudo usermod -aG docker $USER (Restart the linux)
docker build -t containerregistry/node-js-app:1 .
docker login -u containerregistry 
docker push containerregistry/node-js-app:1
docker run -d --name nodejsapp -p 9090:9981 containerregistry/node-js-app:1

Now goto aws and open the port# 9090 in firewall and then copy that public IP and browse with PublicIP:9090. 
we can see the application.

NOTE:
1) Try to use alphine base images wherever its possible.
2) Dont install unneccessery packages which is not requiredto run the application.
3) Try to reduce the layers as much as possible.
4)Use only official images from dockerhub.

To check the networks- docker network ls

==>DOCKER VOLUME: If the container deletes our data will get lost/vanished. but we need that data after deleting the conatiner
also. so in that case we use docker volume,

1)Stateless application: Here we are not maintaining any data. if its crashes we have to create one more application.

2)Stateful application: Here we can store our container data and we can retrive that data after deleting the container also.

 Databases(MySQL,Mongo etc)
cache applications (redis)
Jenkins.


















